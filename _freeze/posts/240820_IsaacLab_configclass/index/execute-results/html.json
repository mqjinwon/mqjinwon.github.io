{
  "hash": "434273225014306fb04e90d6f31ae408",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"IsaacLab의 configclass decorator 역할\"\nauthor: \"김진원\"\ndate: \"2024-08-20\"\ncategories: [nvidia, isaaclab, robotics, rl, python]\nimage: https://isaac-sim.github.io/IsaacLab/_images/isaaclab.jpg\n\nformat: \n  html:\n    code-fold: show   # Optional: Allows code blocks to be folded\n    code-overflow: wrap  # Prevents horizontal scrolling\njupyter: python3\n\ntoc: true  # Optional: Adds a table of contents\n---\n\n\n\n\nconfigclass vs. dataclass 비교하기\n\n---\n\n\n# ✂️TL;DR\n\nconfigclass를 사용하면...\n\n- **Type annotation**과 **Mutable default** 을 자동으로 처리하므로 사용하기 간단함\n- **Class instance**와 **dictionary** 간의 쉬운 변환을 위한 유틸리티 메소드 제공\n- 추가 확인 및 **post-initialization** 를 통해 데이터클래스 기능을 향상\n\n\n\n## Introduction\n\n본 포스팅에서는 python에서 기본적으로 제공하는 `@dataclass`와 IsaacLab에서 사용하는 `@configclass` 간의 차이점을 소개합니다.\n\n\n\n![image-20240820212004490](assets/image-20240820212004490.png)\n\n본 포스팅을 진행하는 이유는 IsaacLab extension 프로젝트인 [IsaacLabExtensionTemplate](https://github.com/isaac-sim/IsaacLabExtensionTemplate) 에서 사용하는 코드 중  위 이미지와 같이 configclass decorator를 발견했는데, 어떠한 용도로 사용되는 지 궁금해서였다.  그래서 설명을 찾아보니 dataclass decorator를 좀 더 확장성 있게 만든 것이라고 설명을 하기에 두가지의 decorator를 비교해보고자 한다.\n\n\n\n## 🌸Decorator란?\n\n우선 Decorator가 뭔지 모를 수도 있으니 간단히 설명하고 넘어가도록 하겠다.\n\n\n\n> [!NOTE]\n>\n> 어떤 함수를 받아 특정 역할을 수행하고 이를 다시 함수의 형태로 반환하는 함수\n\n\n\nPython Decorator 다른 함수를 입력으로 사용하고 명시적으로 수정하지 않고 해당 동작을 확장하거나 변경하는 함수다. Decorator는 일반적으로 깔끔하고 읽기 쉬운 방식으로 함수나 메서드에 기능을 추가하는 데 사용한다.\n\n\n\n**Decorator template**\n\n::: {#16941c06 .cell execution_count=1}\n``` {.python .cell-code}\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        # Code to execute before the function call\n        result = func(*args, **kwargs)\n        # Code to execute after the function call\n        return result\n    return wrapper\n\n@my_decorator\ndef my_function():\n    print(\"Hello, World!\")\n```\n:::\n\n\n위와 같이 my_decorator 를 만들면, 이후의 다른 함수에서 @my_decorator를 붙여서 사용할 수 있다.\n\n\n\n**Example - logging**\n\n::: {#2ede3554 .cell execution_count=2}\n``` {.python .cell-code}\ndef log_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Calling function {func.__name__}\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} returned {result}\")\n        return result\n    return wrapper\n\n@log_decorator\ndef add(a, b):\n    return a + b\n\nadd(3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCalling function add\nadd returned 7\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n7\n```\n:::\n:::\n\n\n위 실험결과로 알 수 있 듯, add 함수를 호출하면 function이 decorator 함수로 들어가서 내부 기능을 수행한 후에 결과값을 뱉어낸다.\n\n\n\n**Example - Timing Decorator**\n\n::: {#439911f4 .cell execution_count=3}\n``` {.python .cell-code}\nimport time\n\ndef timing_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time} seconds\")\n        return result\n    return wrapper\n\n@timing_decorator\ndef compute_square(n):\n    return n * n\n\ncompute_square(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncompute_square took 9.5367431640625e-07 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n100\n```\n:::\n:::\n\n\n위와 같이 시간 측정 시에도 사용할 수 있다.\n\n\n\n**Keypoints**\n\n- **Decorators**: 실제 코드를 변경하지 않고 기능을 수정하거나 향상시킨다.\n\n- **`@` syntax**: `@decorator_name` 문법은 Decorator를 사용하기 위한 방법이다.\n\n\n\n## Dataclass 기능\n\nPython의 dataclass는 dataclasses 모듈(Python 3.7에서 도입됨)이 제공하는 데코레이터이자 유틸리티로, `__init__`, `__repr__`, `__eq__` 등과 같은 특수 메서드를 자동으로 생성한다. 주로 데이터를 저장하고 상용구 코드를 줄이는 데 사용되는 클래스 생성을 단순화하도록 설계되었다.\n\n\n\n`@dataclass`로 클래스를 장식하면 Python은 자동으로 다음 메서드를 생성한다.\n\n- `__init__`: 매개변수를 기반으로 속성을 설정하는 초기화 방법.\n- `__repr__`: 읽을 수 있는 문자열 출력을 제공하는 문자열 표현 방법.\n- `__eq__`: 속성을 기준으로 인스턴스를 비교하는 동등 방법.\n- `__hash__`: 객체를 hashable 하게 만드는 해시 방법(선택 사항, frozen 설정에 따라 다름).\n- `__post_init__`: 추가 초기화를 위해 정의할 수 있는 선택적 메소드.\n\n::: {#428c2bc1 .cell execution_count=4}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n    job: str = \"Unknown\"  # Default value for job\n\n# Creating an instance\np = Person(name=\"Alice\", age=30)\n\n# Accessing attributes\nprint(p.name)  # Output: Alice\nprint(p.age)   # Output: 30\nprint(p.job)   # Output: Unknown\n\n# Automatic __repr__ method\nprint(p)  # Output: Person(name='Alice', age=30, job='Unknown')\n\n# Automatic __eq__ method\np2 = Person(name=\"Alice\", age=30)\nprint(p == p2)  # Output: True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlice\n30\nUnknown\nPerson(name='Alice', age=30, job='Unknown')\nTrue\n```\n:::\n:::\n\n\n## configclass 분석\n\n::: {#05645a69 .cell execution_count=5}\n``` {.python .cell-code}\ndef __dataclass_transform__():\n    \"\"\"Add annotations decorator for PyLance.\"\"\"\n    return lambda a: a\n\n\n@__dataclass_transform__()\ndef configclass(cls, **kwargs):\n    \"\"\"Wrapper around `dataclass` functionality to add extra checks and utilities.\n\n    As of Python 3.7, the standard dataclasses have two main issues which makes them non-generic for\n    configuration use-cases. These include:\n\n    1. Requiring a type annotation for all its members.\n    2. Requiring explicit usage of :meth:`field(default_factory=...)` to reinitialize mutable variables.\n\n    This function provides a decorator that wraps around Python's `dataclass`_ utility to deal with\n    the above two issues. It also provides additional helper functions for dictionary <-> class\n    conversion and easily copying class instances.\n\n    Usage:\n\n    .. code-block:: python\n\n        from dataclasses import MISSING\n\n        from omni.isaac.lab.utils.configclass import configclass\n\n\n        @configclass\n        class ViewerCfg:\n            eye: list = [7.5, 7.5, 7.5]  # field missing on purpose\n            lookat: list = field(default_factory=[0.0, 0.0, 0.0])\n\n\n        @configclass\n        class EnvCfg:\n            num_envs: int = MISSING\n            episode_length: int = 2000\n            viewer: ViewerCfg = ViewerCfg()\n\n        # create configuration instance\n        env_cfg = EnvCfg(num_envs=24)\n\n        # print information as a dictionary\n        print(env_cfg.to_dict())\n\n        # create a copy of the configuration\n        env_cfg_copy = env_cfg.copy()\n\n        # replace arbitrary fields using keyword arguments\n        env_cfg_copy = env_cfg_copy.replace(num_envs=32)\n\n    Args:\n        cls: The class to wrap around.\n        **kwargs: Additional arguments to pass to :func:`dataclass`.\n\n    Returns:\n        The wrapped class.\n\n    .. _dataclass: https://docs.python.org/3/library/dataclasses.html\n    \"\"\"\n    # add type annotations\n    _add_annotation_types(cls)\n    # add field factory\n    _process_mutable_types(cls)\n    # copy mutable members\n    # note: we check if user defined __post_init__ function exists and augment it with our own\n    if hasattr(cls, \"__post_init__\"):\n        setattr(cls, \"__post_init__\", _combined_function(cls.__post_init__, _custom_post_init))\n    else:\n        setattr(cls, \"__post_init__\", _custom_post_init)\n    # add helper functions for dictionary conversion\n    setattr(cls, \"to_dict\", _class_to_dict)\n    setattr(cls, \"from_dict\", _update_class_from_dict)\n    setattr(cls, \"replace\", _replace_class_with_kwargs)\n    setattr(cls, \"copy\", _copy_class)\n    # wrap around dataclass\n    cls = dataclass(cls, **kwargs)\n    # return wrapped class\n    return cls\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}